name: bluebuild
on:
  schedule:
    - cron: "00 06 * * *" # build at 06:00 UTC every day (20 minutes after last ublue images start building)
  push:
    paths-ignore: # don't rebuild if only documentation has changed
      - "**.md"
      - "docs/**"
      - ".rpm-integration-docs/**"
  pull_request:
  workflow_dispatch: # allow manually triggering builds
    inputs:
      force_rebuild:
        description: 'Force rebuild even if no changes detected'
        required: false
        default: false
        type: boolean
concurrency:
  # only run one build at a time
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: true
jobs:
  bluebuild:
    name: Build Custom Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    strategy:
      fail-fast: false # stop GH from cancelling all matrix builds if one fails
      matrix:
        recipe:
          # !! Add your recipes here
          - recipe.yml
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for build necessity
        id: build_check
        run: |
          FORCE_REBUILD="${{ github.event.inputs.force_rebuild || 'false' }}"
          
          if [[ "$FORCE_REBUILD" == "true" ]]; then
            echo "Force rebuild requested, skipping optimization checks"
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "reason=force_rebuild" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # For PR builds, always build
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "Pull request detected, building for validation"
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "reason=pull_request" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if this is a push to main/master
          if [[ "${{ github.event_name }}" == "push" && ("${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/master") ]]; then
            echo "Push to main branch detected, checking for changes"
            
            # Check if only documentation changed using GitHub event context
            # This works reliably in all contexts (shallow clones, first commit, etc.)
            CHANGED_FILES="${{ toJson(github.event.commits.*.modified) }} ${{ toJson(github.event.commits.*.added) }}"
            
            # If GitHub event doesn't have file info, check git history if available
            if [[ -z "$CHANGED_FILES" ]] || [[ "$CHANGED_FILES" == " " ]]; then
              # Check if we have enough history for diff
              if [[ $(git rev-list --count HEAD) -gt 1 ]]; then
                CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git ls-files)
              else
                # First commit, consider all files changed
                CHANGED_FILES=$(git ls-files)
              fi
            fi
            
            if echo "$CHANGED_FILES" | grep -qvE '\.(md|txt)$|^docs/|^\.rpm-integration-docs/'; then
              echo "Non-documentation changes detected, build required"
              echo "should_build=true" >> $GITHUB_OUTPUT
              echo "reason=code_changes" >> $GITHUB_OUTPUT
            else
              echo "Only documentation changes detected, build may be skipped"
              echo "should_build=maybe" >> $GITHUB_OUTPUT
              echo "reason=docs_only" >> $GITHUB_OUTPUT
            fi
          else
            echo "Scheduled or manual build, proceeding with optimization checks"
            echo "should_build=maybe" >> $GITHUB_OUTPUT
            echo "reason=scheduled" >> $GITHUB_OUTPUT
          fi

      - name: Detect base image kernel version
        id: kernel
        run: |
          # Extract kernel version from Aurora base image
          BASE_IMAGE=$(grep "base-image:" recipes/${{ matrix.recipe }} | awk '{print $2}')
          IMAGE_VERSION=$(grep "image-version:" recipes/${{ matrix.recipe }} | awk '{print $2}')
          FULL_IMAGE="${BASE_IMAGE}:${IMAGE_VERSION}"
          
          echo "Detecting kernel version from base image: $FULL_IMAGE"
          
          # Get kernel version from image labels
          KERNEL_VERSION=$(skopeo inspect "docker://$FULL_IMAGE" | jq -r '.Labels["ostree.linux"] // empty')
          
          if [[ -z "$KERNEL_VERSION" ]]; then
            echo "Warning: Could not detect kernel version from image labels, trying alternative method..."
            # Fallback: try to get from image config
            KERNEL_VERSION=$(skopeo inspect "docker://$FULL_IMAGE" | jq -r '.Config.Labels["ostree.linux"] // empty')
          fi
          
          if [[ -z "$KERNEL_VERSION" ]]; then
            echo "Error: Could not detect kernel version from base image"
            exit 1
          fi
          
          # Extract Fedora version from kernel version
          FEDORA_VERSION=$(echo "$KERNEL_VERSION" | sed -n 's/.*\.fc\([0-9]\+\)\..*/\1/p')
          if [[ -z "$FEDORA_VERSION" ]]; then
            echo "Warning: Could not extract Fedora version, defaulting to 41"
            FEDORA_VERSION="41"
          fi
          
          echo "version=$KERNEL_VERSION" >> $GITHUB_OUTPUT
          echo "fedora_version=$FEDORA_VERSION" >> $GITHUB_OUTPUT
          echo "base_image=$FULL_IMAGE" >> $GITHUB_OUTPUT
          
          echo "Detected kernel version: $KERNEL_VERSION"
          echo "Detected Fedora version: $FEDORA_VERSION"

      - name: Check Aurora base image changes
        id: aurora_check
        run: |
          BASE_IMAGE="${{ steps.kernel.outputs.base_image }}"
          KERNEL_VERSION="${{ steps.kernel.outputs.version }}"
          
          # Get the digest of the current base image
          CURRENT_DIGEST=$(skopeo inspect "docker://$BASE_IMAGE" | jq -r '.Digest')
          
          # Check if we have a previous build with the same kernel version
          CACHE_KEY="aurora-${KERNEL_VERSION}"
          
          echo "current_digest=$CURRENT_DIGEST" >> $GITHUB_OUTPUT
          echo "cache_key=$CACHE_KEY" >> $GITHUB_OUTPUT
          echo "Aurora base image digest: $CURRENT_DIGEST"
          echo "Cache key: $CACHE_KEY"
          
          # Store digest for caching
          mkdir -p .cache
          echo "$CURRENT_DIGEST" > .cache/aurora-digest
          echo "$KERNEL_VERSION" > .cache/kernel-version

      - name: Cache Aurora base image info
        uses: actions/cache@v4
        id: aurora_cache
        with:
          path: .cache
          key: ${{ steps.aurora_check.outputs.cache_key }}-${{ steps.aurora_check.outputs.current_digest }}
          restore-keys: |
            ${{ steps.aurora_check.outputs.cache_key }}-



      - name: Determine if build should proceed
        id: final_build_check
        run: |
          INITIAL_CHECK="${{ steps.build_check.outputs.should_build }}"
          AURORA_CACHE_HIT="${{ steps.aurora_cache.outputs.cache-hit }}"
          
          echo "Initial build check: $INITIAL_CHECK"
          echo "Aurora cache hit: $AURORA_CACHE_HIT"
          
          # Force build conditions
          if [[ "$INITIAL_CHECK" == "true" ]]; then
            echo "Build required due to: ${{ steps.build_check.outputs.reason }}"
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "skip_reason=none" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Optimization conditions
          if [[ "$AURORA_CACHE_HIT" == "true" ]]; then
            echo "Aurora base unchanged - build can be skipped"
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "skip_reason=no_changes" >> $GITHUB_OUTPUT
          else
            echo "Aurora base image has changed - build required"
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "skip_reason=none" >> $GITHUB_OUTPUT
          fi

      - name: Report build decision
        run: |
          SHOULD_BUILD="${{ steps.final_build_check.outputs.should_build }}"
          SKIP_REASON="${{ steps.final_build_check.outputs.skip_reason }}"
          
          if [[ "$SHOULD_BUILD" == "true" ]]; then
            echo "✅ Build will proceed"
          else
            echo "⏭️ Build will be skipped: $SKIP_REASON"
            echo "To force a build, use workflow_dispatch with force_rebuild=true"
          fi



      # the build is fully handled by the reusable github action
      - name: Build Custom Image
        if: steps.final_build_check.outputs.should_build == 'true'
        uses: blue-build/github-action@v1.9
        with:
          recipe: ${{ matrix.recipe }}
          # Using keyless signing (recommended) - omit cosign_private_key for keyless signing
          # cosign_private_key: ${{ secrets.SIGNING_SECRET }}  # Only for private key signing
          registry_token: ${{ github.token }}
          pr_event_number: ${{ github.event.number }}
          # enabled by default, disable if your image is small and you want faster builds
          maximize_build_space: true
          # Uncomment to pin maccel to a specific version (default: latest)
          # env:
          #   MACCEL_VERSION: "0.4.1"

      - name: Generate additional image tags
        if: success() && steps.final_build_check.outputs.should_build == 'true' && github.event_name != 'pull_request'
        id: tags
        run: |
          KERNEL_VERSION="${{ steps.kernel.outputs.version }}"
          FEDORA_VERSION="${{ steps.kernel.outputs.fedora_version }}"
          TIMESTAMP=$(date -u +"%Y%m%d")
          
          # Generate semantic tags
          KERNEL_TAG="kernel-${KERNEL_VERSION}"
          FEDORA_TAG="fedora-${FEDORA_VERSION}"
          DATE_TAG="${TIMESTAMP}"
          
          echo "kernel_tag=${KERNEL_TAG}" >> $GITHUB_OUTPUT
          echo "fedora_tag=${FEDORA_TAG}" >> $GITHUB_OUTPUT
          echo "date_tag=${DATE_TAG}" >> $GITHUB_OUTPUT
          
          echo "Generated tags:"
          echo "  - ${KERNEL_TAG}"
          echo "  - ${FEDORA_TAG}"
          echo "  - ${DATE_TAG}"

      - name: Tag image with additional tags
        if: success() && steps.final_build_check.outputs.should_build == 'true' && github.event_name != 'pull_request'
        run: |
          IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/myaurorabluebuild"
          
          # Pull the latest image that was just built
          podman pull "${IMAGE_NAME}:latest"
          
          # Tag with semantic versions
          podman tag "${IMAGE_NAME}:latest" "${IMAGE_NAME}:${{ steps.tags.outputs.kernel_tag }}"
          podman tag "${IMAGE_NAME}:latest" "${IMAGE_NAME}:${{ steps.tags.outputs.fedora_tag }}"
          podman tag "${IMAGE_NAME}:latest" "${IMAGE_NAME}:${{ steps.tags.outputs.date_tag }}"
          
          # Push additional tags
          podman push "${IMAGE_NAME}:${{ steps.tags.outputs.kernel_tag }}"
          podman push "${IMAGE_NAME}:${{ steps.tags.outputs.fedora_tag }}"
          podman push "${IMAGE_NAME}:${{ steps.tags.outputs.date_tag }}"
          
          echo "Successfully tagged and pushed additional image tags"

      - name: Validate image signing
        if: success() && steps.final_build_check.outputs.should_build == 'true' && github.event_name != 'pull_request'
        run: |
          echo "Validating image signature..."
          
          IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/myaurorabluebuild:latest"
          
          # Wait a moment for image to be fully available
          sleep 10
          
          # Verify keyless signature (cosign provided by Blue Build action)
          echo "Verifying keyless signature..."
          cosign verify \
            --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            "$IMAGE_NAME"
          
          echo "✅ Image signature validation successful!"

      - name: Generate verification documentation
        if: success() && steps.final_build_check.outputs.should_build == 'true' && github.event_name != 'pull_request'
        run: |
          IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/myaurorabluebuild"
          KERNEL_VERSION="${{ steps.kernel.outputs.version }}"
          
          echo "=== Image Verification Commands ==="
          echo ""
          echo "# Verify latest image:"
          echo "cosign verify \\"
          echo "  --certificate-identity-regexp=\"https://github.com/${{ github.repository }}\" \\"
          echo "  --certificate-oidc-issuer=\"https://token.actions.githubusercontent.com\" \\"
          echo "  ${IMAGE_NAME}:latest"
          echo ""
          echo "# Verify kernel-specific tag:"
          echo "cosign verify \\"
          echo "  --certificate-identity-regexp=\"https://github.com/${{ github.repository }}\" \\"
          echo "  --certificate-oidc-issuer=\"https://token.actions.githubusercontent.com\" \\"
          echo "  ${IMAGE_NAME}:kernel-${KERNEL_VERSION}"
          echo ""
          echo "# Install with signature verification:"
          echo "rpm-ostree rebase ostree-image-signed:docker://${IMAGE_NAME}:latest"
          echo ""
          echo "==================================="

      - name: Report build completion
        if: always()
        run: |
          BUILD_STATUS="${{ job.status }}"
          SHOULD_BUILD="${{ steps.final_build_check.outputs.should_build }}"
          SKIP_REASON="${{ steps.final_build_check.outputs.skip_reason }}"
          
          echo "=== Build Report ==="
          echo "Job Status: $BUILD_STATUS"
          echo "Should Build: $SHOULD_BUILD"
          
          if [[ "$SHOULD_BUILD" == "false" ]]; then
            echo "Build Status: SKIPPED ($SKIP_REASON)"
            echo "Aurora Base: ${{ steps.kernel.outputs.base_image }}"
            echo "Kernel Version: ${{ steps.kernel.outputs.version }}"
            echo "Cache Hit: ${{ steps.aurora_cache.outputs.cache-hit }}"
          elif [[ "$BUILD_STATUS" == "success" ]]; then
            echo "Build Status: SUCCESS"
            echo "Image Built: ghcr.io/${{ github.repository_owner }}/myaurorabluebuild:latest"
            echo "Aurora Base: ${{ steps.kernel.outputs.base_image }}"
            echo "Kernel Version: ${{ steps.kernel.outputs.version }}"
            echo "Signature: Keyless cosign (GitHub OIDC)"
            echo "Verification: See commands above"
          else
            echo "Build Status: FAILED"
            echo "Check the logs above for error details"
          fi
          echo "=================="

      - name: Update build cache on success
        if: success() && steps.final_build_check.outputs.should_build == 'true'
        run: |
          # Update cache with successful build info
          echo "Build completed successfully at $(date -u +"%Y-%m-%dT%H:%M:%SZ")" > .cache/last-successful-build
          echo "${{ steps.kernel.outputs.version }}" > .cache/last-kernel-version
          echo "Cache updated for future build optimizations"

      - name: Clean up old container images
        if: (success() || failure()) && steps.final_build_check.outputs.should_build == 'true' && github.event_name != 'pull_request'
        uses: snok/container-retention-policy@v3.0.0
        with:
          image-names: myaurorabluebuild
          cut-off: 60 days ago UTC  # Keep images for 2 months
          account-type: personal
          org-name: ${{ github.repository_owner }}
          keep-at-least: 5  # Always keep at least 5 images
          untagged-only: false  # Clean both tagged and untagged
          skip-tags: latest  # Never delete 'latest' tag
          token: ${{ github.token }}

